# 缓冲流

字节缓冲流	字符缓冲流

Buffered

## 字节缓冲流

原理：底层自带了长度为8192的缓冲区提高性能

练习：

利用字节缓冲流拷贝文件

```java
public static void main(String[] args) throws IOException {
    // 1.创建缓冲流对象
    BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.txt"));
    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("b.txt"));
    // 2.循环读取，写到目的地
    int b;
    while ((b = bis.read()) != - 1) {
        bos.write(b);
    }
    // 3.释放资源
    bos.close();
    bis.close();
}
```

```java
public static void main(String[] args) throws IOException {
    // 1.创建缓冲区对象
    BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.txt"));
    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("b.txt"));
    // 2.拷贝（一次读写多个字节）
    byte[] bytes = new byte[1024];
    int len;
    while ((len = bis.read(bytes)) != - 1) {
        bos.write(bytes, 0, len);
    }
    // 3.释放资源
    bos.close();
    bis.close();
}
```

字节缓冲流提高效率的原理

没有缓冲区更多的是硬盘和硬盘之间打交道，多了缓冲区（内存中），在缓冲区中一次交换8192字节的数据，节省的是这部分时间

## 字符缓冲流

原理：底层自带长度为8192的缓冲区提高性能

```java
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader("a.txt"));
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
    br.close();
}
```

```java
public static void main(String[] args) throws IOException {
    // 1.创建字节缓冲输出流对象
    BufferedWriter bw = new BufferedWriter(new FileWriter("b.txt", true));
    // 2.写数据
    bw.write("你好，我是");
    bw.newLine();
    bw.write("张三");
    bw.newLine();
    // 3.释放资源
    bw.close();
}
```

## 总结

```
1.缓冲流有几种？

​	字节缓冲输入流：BufferedInputStream

​	字节缓冲输出流：BufferedOutputStream

​	字符缓冲输入流：BufferedReader

​	字符缓冲输出流：BufferedWriter

2.缓冲流为什么能提高性能？

​	缓冲流自带长度为8192的缓冲区

​	可以显著提高字节流的读写性能

​	对于字符流提升不明显，对于字符缓冲流而言关键点是两个特有的方法

3.字符缓冲流两个特有的方法是什么？

​	字符缓冲输入流BufferedReader：readLine()

​	字符缓冲输出流BufferedWriter：newLine()
```

## 练习

#### 练习1

四种方式拷贝文件，并统计各自用时

字节流的基本流：一次读写一个字节

字节流的基本流：一次读写一个数组

字节缓冲流：一次读写一个字节

字节缓冲流：一次读写一个字节数组

#### 练习2

需求：把《出师表》的文章顺序进行恢复到一个新文件中

```
3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
4.将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
9.今当远离，临表涕零，不知所言。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
```

```java
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader("a.txt"));
    ArrayList<String> list = new ArrayList<>();
    String line;
    while ((line = br.readLine()) != null) {
        list.add(line);
    }
    // 2.排序
    Collections.sort(list, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            // 获取o1，o2的序号
            int i1 = Integer.parseInt(o1.split("\\.")[0]);
            int i2 = Integer.parseInt(o2.split("\\.")[0]);
            return i1 - i2;
        }
    });
    BufferedWriter bw = new BufferedWriter(new FileWriter("b.txt"));
    for (String str : list) {
        bw.write(str);
        bw.newLine();
    }
    br.close();
    bw.close();
}
```

```java
public static void main(String[] args) throws IOException {

    BufferedReader br = new BufferedReader(new FileReader("a.txt"));
    String line;
    TreeMap<Integer, String> treeMap = new TreeMap<>();
    while ((line = br.readLine()) != null) {
        String[] arr = line.split("\\.");
        treeMap.put(Integer.parseInt(arr[0]), arr[1]);
    }
    br.close();

    BufferedWriter bw = new BufferedWriter(new FileWriter("b.txt"));
    Set<Map.Entry<Integer, String>> entries = treeMap.entrySet();
    for (Map.Entry<Integer, String> entry : entries) {
        String value = entry.getValue();
        bw.write(value);
        bw.newLine();
    }
    bw.close();
}
```

#### 练习3

需求：

实现一个验证程序运行次数的小程序：

​	当程序运行超过3次后提示：本软件只能免费使用3次，欢迎您注册会员后继续使用

​	程序运行演示如下：

​		第一次运行控制台输出：欢迎使用本软件，第1次使用免费

​		第二次。。。。。。

​		第三次。。。。。。

​		第四次：本软件只能免费使用次，请您注册会员后继续使用

```Java
public static void main(String[] args) throws IOException {
    /*
    需求：
    实现一个验证程序运行次数的小程序：
        当程序运行超过3次后提示：本软件只能免费使用3次，欢迎您注册会员后继续使用
        程序运行演示如下：
        第一次运行控制台输出：欢迎使用本软件，第1次使用免费
        第二次。。。。。。
        第三次。。。。。。
  第四次：本软件只能免费使用次，请您注册会员后继续使用
     */
    BufferedReader br = new BufferedReader(new FileReader("a.txt"));
    String line = br.readLine();
    int count = Integer.parseInt(line);
    count++;
    if (count <= 3) {
        System.out.println("欢迎使用本软件，第" + count + "次使用免费~");
    } else {
        System.out.println("本软件只能免费使用3次，欢迎您注册会员后继续使用~");
    }
    
    // 小细节：
    // 	输出流在关联文件时会把文件清空
    BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));
    // 这里注意写入的要是字符串！！！
    bw.write(count + "");
    bw.close();
    br.close();
}
```

```
原则：
	IO流：
		随用随创建
		什么时候不用什么时候关闭
```

# 转换流

转换流是字符流和字节流之间的桥梁

作用1：指定字符集读写（淘汰了）

作用2：字节流想要使用字符流中的方法

## 练习

#### 练习1

转换文件编码

需求1：手动创建一个GBK文件，把文件中的中文读取到内存中，不能出现乱码

需求2：把一段中文按照GBK的方式写到本地文件

需求3：将本地文件中的GBK文件，转成UTF-8

已被淘汰

```java
public static void main(String[] args) throws IOException {
    // 1.创建对象并指定字符编码
    InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"), "GBK");
    // 2.读取数据
    int ch;
    while ((ch = isr.read()) != - 1) {
        System.out.print((char) ch);
    }
    // 3.释放资源
    isr.close();
}
```

**掌握**

```java
FileReader fr = new FileReader("a.txt", Charset.forName("GBK"));
int ch;
while ((ch = fr.read()) != - 1) {
    System.out.print((char) ch);
}
fr.close();
```

被淘汰

```java
// 1.创建转换流对象
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("a.txt"), "GBK");
// 2.写出数据
osw.write("你好");
// 3.释放资源
osw.close();
```

**掌握**

```java
FileWriter fw = new FileWriter("a.txt", Charset.forName("GBK"));
fw.write("你好！！！");
fw.close();
```

```java
public static void main(String[] args) throws IOException {
    FileReader fr = new FileReader("a.txt", Charset.forName("GBK"));
    FileWriter fw = new FileWriter("b.txt", Charset.forName("UTF-8"));
    int b;
    while ((b = fr.read()) != - 1) {
        fw.write(b);
    }
    fw.close();
    fr.close();
}
```

#### 练习2

读取文件中的数据

利用字节流读取文件中的数据，每次读取一整行，而且不能出现乱码

```java
BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("a.txt")));
String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}
br.close();
```

## 总结

```
1.转换流的名字是什么？

​	字符转换输入流：InputStreamReader

​	字符转换输出流：OutputStreamWriter

2.转换流的作用是什么？

​	指定字符集读写数据（JDK11之后已淘汰)

​	字节流想要使用字符流中的方法了
```

# 序列化流

序列化流可以把Java中的对象写到本地文件中

小细节：

​	使用对象输出流将对象保存到文件时会出现NotSerializableException异常

解决方案：需要让Javabean类实现Serializable接口

```java
public static void main(String[] args) throws IOException {
    /*
    需求：
        利用序列化流/对象操作输出流，把一个对象写到本地文件中
        构造方法：
            public ObjectOutputStream(OutputStream out) 把基本流变成高级流
        成员方法：
			public final void writeObject(Object obj)	把对象序列化（写出）到文件中去
     */

    // 1.创建对象
    Student stu = new Student("zhangsan", 23);
    // 2.创建序列化流的对象/对象操作输出流
    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("a.txt"));
    // 3.写数据
    oos.writeObject(stu);
    // 4.释放资源
    oos.close();
```

```java
/* Serializable接口里面是没有抽象方法的，标记型接口
    一旦实现了这个接口，那么就表示当前的Student类可以被序列化
理解：
    一个物品的合格证，有了它才能被序列化*/
public class Student implements Serializable {
    @Serial
    private static final long serialVersionUID = 7450306263492828023L;
    private String name;
    private int age;
    // transient瞬态关键字
    // 作用：不会把当前属性序列化到本地文件当中
    private transient String address;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public String getAddress() {
        return address;
    }
    
    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{name = " + name + ", age = " + age + ", address = " + address + "}";
    }
}
```

# 反序列化流

反序列化流/对象操作输入流：可以把序列化到本地文件中的对象，读取到程序中来

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
        /*
        反序列化流/对象操作输入流
        构造方法：
            public ObjectInputStream(InputStream out)   把基本流变成高级流
        成员方法：
            public Object readObject()  把序列化到本地文件中的对象，读取到程序中来
         */
        // 1.创建反序列化流的对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("a.txt"));
        // 2.读取数据
        Object o = ois.readObject();
        // 3.打印对象
        System.out.println(o);
        // 4.释放资源
        ois.close();
    }
```

## 总结

①使用序列化流将对象写到文件时，需要让Javabean类实现**Serializable**接口

②序列化流写到文件中的数据是不能修改的，一旦修改就无法再次读回来了

③序列化对象后，修改了Javabean类，再次反序列化，会不会有问题？

​	会出问题，会抛出**InvalidClassException**异常

​	解决方案：给Javabean类添加**serialVersionUID**（序列号、版本号）

④如果一个对象中的某一个成员变量的值不想被序列化，又该如何实现呢？

​	**解决方案**：给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程

## 练习

#### 练习1

需求：将多个自定义的对象序列化到文件中，但是对象的个数不确定，该如何操作？

```java
public static void main(String[] args) throws IOException {
    // 1.序列化多个对象
    Student stu1 = new Student("张三", 23, "北京");
    Student stu2 = new Student("李四", 24, "重庆");
    Student stu3 = new Student("王五", 25, "南京");

    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("a.txt"));

    ArrayList<Student> list = new ArrayList<>();
    list.add(stu1);
    list.add(stu2);
    list.add(stu3);
    oos.writeObject(list);
    oos.close();
}
```

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
    // 创建反序列化流的对象
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream("a.txt"));
    ArrayList<Student> list = (ArrayList<Student>) ois.readObject();
    for (Student student : list) {
        System.out.println(student);
    }
    ois.close();
}
```

# 打印流

分类：打印流一般是指：PrintStream，PrintWriter两个类

特点1：打印流只能操作文件目的地，不能操作数据源

特点2：特有的数据方法可以实现，数据原样写出

特点3：特有的写出方法，可以实现自动刷新，自动换行

​				打印一次数据 = 写出 + 换行 + 刷新

## 字节打印流

```java
public static void main(String[] args) throws FileNotFoundException {
    // 1.创建字节打印流的对象
    PrintStream ps = new PrintStream(new FileOutputStream("a.txt"), true, Charset.forName("UTF-8"));
    // 2.写出对象
    // 写出 + 自动刷新 + 自动换行
    ps.print(97);
    ps.println();
    ps.print(true);
    ps.println();
    ps.printf("%s爱上了%s", "阿珍", "阿强");
    // 3.释放资源
    ps.close();
}
```

## 字符打印流

字符流底层有缓冲区，想要自动刷新需要开启

```java
public static void main(String[] args) throws IOException {
    // 1.创建字符打印流的对象
    PrintWriter pw = new PrintWriter(new FileWriter("a.txt"), true);
    // 2.写出数据
    pw.println("你好，古德猫宁");
    pw.print(97);
    pw.print(true);
    pw.printf("%s爱上了%s", "阿珍", "阿强");
    // 3.释放资源
    pw.close();
}
```

## 总结

1.打印流有几种？各有什么特点？

**字节打印流**和**字符打印流**两种

打印流不能操作数据源，只能操作目的地

字节打印流：默认自动刷新，特有的println自动换行

字符打印流：自动刷新需要手动开启，特有的println自动换行

# 解压缩流/压缩流

## 解压缩流

```java
public static void main(String[] args) throws IOException {
    // 1.创建一个File表示要解压的压缩包
    File src = new File("D:\\aaa\\备份.zip");
    // 2.创建一个File表示解压的目的地
    File dest = new File("D:\\aaa");
    unzip(src, dest);

}

/**
 * @param src 源压缩包地址
 * @param dest 目标地址
 * @Description: 解压缩文件
 * @Author: LiXiaoYang
 * @Date: 2024/11/5 21:12
 */
public static void unzip(File src, File dest) throws IOException {
    // 解压的本质：把压缩包里面的每一个文件或者文件夹读取出来按照层级拷贝到目的地中
    ZipInputStream zip = new ZipInputStream(new FileInputStream(src));
    // 先获取到压缩包里面的每一个zipentry对象

    ZipEntry entry;
    while ((entry = zip.getNextEntry()) != null) {
        if (entry.isDirectory()) {
            // 文件夹：需要在目的地dest处创建一个相同的文件夹
            File file = new File(dest, entry.toString());
            file.mkdirs();
        } else {
            // 文件：需要读取到压缩包中的文件，并把他存放在目的地dest文件夹中，需要按照层级存放
            FileOutputStream fos = new FileOutputStream(new File(dest, entry.toString()));
            int b;
            while ((b = zip.read()) != - 1) {
                // 写到目的地
                fos.write(b);
            }
            fos.close();
            // 表示在压缩包中的一个文件处理完毕了
            zip.closeEntry();
        }
    }
    zip.close();
}
```

## 压缩流

压缩本质：把每一个（文件/文件夹）看作ZipEntry对象放到压缩包中

单个文件压缩

```java
public static void main(String[] args) throws IOException {
    /*
    单个文件压缩
     */
    // 1.创建File对象表示要压缩的文件
    File src = new File("D:\\aaa\\a.txt");
    // 2.创建File对象表示压缩包位置
    File dest = new File("D:\\aaa");
    // 3.调用方法用来压缩
    toZip(src, dest);
}

/**
 * @param src  要压缩文件
 * @param dest 压缩包位置
 * @Description: 压缩文件
 * @Author: LiXiaoYang
 * @Date: 2024/11/5 21:18
 */
public static void toZip(File src, File dest) throws IOException {
    // 1.创建压缩流关联压缩包
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest, "a.zip")));
    // 2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹
    ZipEntry entry = new ZipEntry("a.txt");
    // 3.把ZipEntry对象放到压缩包当中
    zos.putNextEntry(entry);
    // 4.把src文件中的数据写到压缩包当中
    FileInputStream fis = new FileInputStream(src);
    int b;
    while ((b = fis.read()) != - 1) {
        zos.write(b);
    }

    fis.close();
    zos.closeEntry();
    zos.close();
}
```

文件夹压缩

```java
public static void main(String[] args) throws IOException {
    /*
    文件夹压缩
     */
    // 1.创建File对象表示要压缩的文件夹
    File src = new File("D:\\aaa");
    // 2.创建File对象表示压缩包放最哪里（压缩包的父级路径）
    File destParent = src.getParentFile();
    // 3.创建File对象表示压缩包的路径
    File dest = new File(destParent, src.getName() + ".zip");
    // 4.创建压缩流关联压缩包
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));
    // 5.获取src里面的每一个文件，变成ZipEntry对象，放到压缩包当中
    toZip(src, zos, src.getName());
    // 6.释放资源
    zos.close();
}

/**
 * @param src  要压缩的文件夹
 * @param zos  压缩流
 * @param name 压缩包内部的路径
 * @Description: 压缩文件夹，获取src里面的每一个文件，变成ZipEntry对象，放到压缩包当中
 * @Author: LiXiaoYang
 * @Date: 2024/11/5 21:39
 */
public static void toZip(File src, ZipOutputStream zos, String name) throws IOException {
    // 1.进入src文件夹
    File[] files = src.listFiles();
    // 2.遍历数组
    for (File file : files) {
        if (file.isFile()) {
            // 如果是文件，变成ZipEntry对象，放到压缩包当中
            ZipEntry entry = new ZipEntry(name + "\\" + file.getName());
            zos.putNextEntry(entry);
            // 读取文件中的数据，写到压缩包中
            FileInputStream fis = new FileInputStream(file);
            int b;
            while ((b = fis.read()) != - 1) {
                zos.write(b);
            }
            fis.close();
            zos.closeEntry();
        } else {
            // 如果是文件夹，递归
            toZip(file, zos, name + "\\" + file.getName());
        }
    }
}
```
