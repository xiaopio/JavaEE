# 线程的7种状态

1. **新建（New）**：
   - 当一个线程被创建但还没有调用`start()`方法时，它处于新建状态。
   - 例如：`Thread thread = new Thread();`，此时线程就是新建状态。
2. **就绪（Runnable）**：
   - 一旦调用了`start()`方法，线程就进入就绪状态，准备被操作系统调度执行。
   - 在这个状态下，线程可能正在等待 CPU 时间片，或者已经在就绪队列中等待被调度。
   - 例如：`thread.start();`之后，线程可能很快进入运行状态，也可能需要等待一段时间。
3. **运行（Running）**：
   - 当线程被操作系统调度并获得 CPU 时间片时，它处于运行状态，正在执行其`run()`方法中的代码。
   - 例如：线程正在执行一系列的计算或者操作。
4. **阻塞（Blocked）**：
   - 当线程因为等待某个资源（如锁、I/O 操作等）而暂时无法继续执行时，它进入阻塞状态。
   - 例如：一个线程在等待进入一个同步代码块，而另一个线程持有该同步代码块的锁，那么等待的线程就处于阻塞状态。
   - 当阻塞的条件满足时，线程会重新进入就绪状态等待被调度执行。
5. **等待（Waiting）**：
   - 线程进入等待状态是通过调用`Object.wait()`、`Thread.join()`或`LockSupport.park()`等方法。
   - 在等待状态下，线程会一直等待，直到被其他线程通过`Object.notify()`、`Object.notifyAll()`或`LockSupport.unpark()`等方法唤醒。
   - 例如：一个线程调用了`obj.wait()`方法，它会释放锁并进入等待状态，直到另一个线程调用`obj.notify()`或`obj.notifyAll()`方法唤醒它。
6. **超时等待（Timed Waiting）**：
   - 与等待状态类似，但它会在指定的时间后自动唤醒。
   - 例如：线程调用`Thread.sleep(long millis)`、`Object.wait(long timeout)`或`LockSupport.parkNanos(long nanos)`等方法进入超时等待状态。
   - 如果在指定时间内没有被唤醒，线程会自动进入就绪状态。
7. **终止（Terminated）**：
   - 当线程的`run()`方法执行完毕，或者因为异常而退出时，线程进入终止状态。
   - 一旦线程进入终止状态，就不能再重新启动。
   - 例如：线程完成了所有任务或者发生了未捕获的异常，导致线程结束。

**Java虚拟机中是没有定义运行状态的**

原因：当线程抢夺到CPU的执行权时，JVM就会把线程交给系统进行执行，不归JVM管

![线程的6种状态](D:\admin\Pictures\Typora\线程的6种状态.png)